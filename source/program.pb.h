// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: program.proto

#ifndef PROTOBUF_program_2eproto__INCLUDED
#define PROTOBUF_program_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_program_2eproto();
void protobuf_AssignDesc_program_2eproto();
void protobuf_ShutdownFile_program_2eproto();

class Program;
class Statement;
class Instruction;
class Opcode;
class Operand;
class Data;

enum Statement_Type {
  Statement_Type_INSTRUCTION = 0,
  Statement_Type_LABEL = 1,
  Statement_Type_DATA = 2,
  Statement_Type_COMMENT = 3,
  Statement_Type_BLANK_SPACE = 4
};
bool Statement_Type_IsValid(int value);
const Statement_Type Statement_Type_Type_MIN = Statement_Type_INSTRUCTION;
const Statement_Type Statement_Type_Type_MAX = Statement_Type_BLANK_SPACE;
const int Statement_Type_Type_ARRAYSIZE = Statement_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Statement_Type_descriptor();
inline const ::std::string& Statement_Type_Name(Statement_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Statement_Type_descriptor(), value);
}
inline bool Statement_Type_Parse(
    const ::std::string& name, Statement_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Statement_Type>(
    Statement_Type_descriptor(), name, value);
}
enum Opcode_Type {
  Opcode_Type_BASIC = 0,
  Opcode_Type_ADVANCED = 1
};
bool Opcode_Type_IsValid(int value);
const Opcode_Type Opcode_Type_Type_MIN = Opcode_Type_BASIC;
const Opcode_Type Opcode_Type_Type_MAX = Opcode_Type_ADVANCED;
const int Opcode_Type_Type_ARRAYSIZE = Opcode_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Opcode_Type_descriptor();
inline const ::std::string& Opcode_Type_Name(Opcode_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Opcode_Type_descriptor(), value);
}
inline bool Opcode_Type_Parse(
    const ::std::string& name, Opcode_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Opcode_Type>(
    Opcode_Type_descriptor(), name, value);
}
enum Opcode_Basic {
  Opcode_Basic_SET = 1,
  Opcode_Basic_ADD = 2,
  Opcode_Basic_SUB = 3,
  Opcode_Basic_MUL = 4,
  Opcode_Basic_MLI = 5,
  Opcode_Basic_DIV = 6,
  Opcode_Basic_DVI = 7,
  Opcode_Basic_MOD = 8,
  Opcode_Basic_AND = 9,
  Opcode_Basic_BOR = 10,
  Opcode_Basic_XOR = 11,
  Opcode_Basic_SHR = 12,
  Opcode_Basic_ASR = 13,
  Opcode_Basic_SHL = 14,
  Opcode_Basic_MVI = 15,
  Opcode_Basic_IFB = 16,
  Opcode_Basic_IFC = 17,
  Opcode_Basic_IFE = 18,
  Opcode_Basic_IFN = 19,
  Opcode_Basic_IFG = 20,
  Opcode_Basic_IFA = 21,
  Opcode_Basic_IFL = 22,
  Opcode_Basic_IFU = 23,
  Opcode_Basic_ADX = 26,
  Opcode_Basic_SUX = 27
};
bool Opcode_Basic_IsValid(int value);
const Opcode_Basic Opcode_Basic_Basic_MIN = Opcode_Basic_SET;
const Opcode_Basic Opcode_Basic_Basic_MAX = Opcode_Basic_SUX;
const int Opcode_Basic_Basic_ARRAYSIZE = Opcode_Basic_Basic_MAX + 1;

const ::google::protobuf::EnumDescriptor* Opcode_Basic_descriptor();
inline const ::std::string& Opcode_Basic_Name(Opcode_Basic value) {
  return ::google::protobuf::internal::NameOfEnum(
    Opcode_Basic_descriptor(), value);
}
inline bool Opcode_Basic_Parse(
    const ::std::string& name, Opcode_Basic* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Opcode_Basic>(
    Opcode_Basic_descriptor(), name, value);
}
enum Opcode_Advanced {
  Opcode_Advanced_JSR = 1,
  Opcode_Advanced_INT = 8,
  Opcode_Advanced_IAG = 9,
  Opcode_Advanced_IAS = 10,
  Opcode_Advanced_HWN = 16,
  Opcode_Advanced_HWQ = 17,
  Opcode_Advanced_HWI = 18
};
bool Opcode_Advanced_IsValid(int value);
const Opcode_Advanced Opcode_Advanced_Advanced_MIN = Opcode_Advanced_JSR;
const Opcode_Advanced Opcode_Advanced_Advanced_MAX = Opcode_Advanced_HWI;
const int Opcode_Advanced_Advanced_ARRAYSIZE = Opcode_Advanced_Advanced_MAX + 1;

const ::google::protobuf::EnumDescriptor* Opcode_Advanced_descriptor();
inline const ::std::string& Opcode_Advanced_Name(Opcode_Advanced value) {
  return ::google::protobuf::internal::NameOfEnum(
    Opcode_Advanced_descriptor(), value);
}
inline bool Opcode_Advanced_Parse(
    const ::std::string& name, Opcode_Advanced* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Opcode_Advanced>(
    Opcode_Advanced_descriptor(), name, value);
}
enum Operand_Type {
  Operand_Type_REGISTER = 0,
  Operand_Type_LOCATION_IN_REGISTER = 8,
  Operand_Type_LOCATION_OFFSET_BY_REGISTER = 16,
  Operand_Type_PUSH_POP = 24,
  Operand_Type_PEEK = 25,
  Operand_Type_PICK = 26,
  Operand_Type_STACK_POINTER = 27,
  Operand_Type_PROGRAM_COUNTER = 28,
  Operand_Type_EXTRA = 29,
  Operand_Type_LOCATION = 30,
  Operand_Type_LITERAL = 31
};
bool Operand_Type_IsValid(int value);
const Operand_Type Operand_Type_Type_MIN = Operand_Type_REGISTER;
const Operand_Type Operand_Type_Type_MAX = Operand_Type_LITERAL;
const int Operand_Type_Type_ARRAYSIZE = Operand_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Operand_Type_descriptor();
inline const ::std::string& Operand_Type_Name(Operand_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Operand_Type_descriptor(), value);
}
inline bool Operand_Type_Parse(
    const ::std::string& name, Operand_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Operand_Type>(
    Operand_Type_descriptor(), name, value);
}
enum Operand_Register {
  Operand_Register_A = 0,
  Operand_Register_B = 1,
  Operand_Register_C = 2,
  Operand_Register_X = 3,
  Operand_Register_Y = 4,
  Operand_Register_Z = 5,
  Operand_Register_I = 6,
  Operand_Register_J = 7
};
bool Operand_Register_IsValid(int value);
const Operand_Register Operand_Register_Register_MIN = Operand_Register_A;
const Operand_Register Operand_Register_Register_MAX = Operand_Register_J;
const int Operand_Register_Register_ARRAYSIZE = Operand_Register_Register_MAX + 1;

const ::google::protobuf::EnumDescriptor* Operand_Register_descriptor();
inline const ::std::string& Operand_Register_Name(Operand_Register value) {
  return ::google::protobuf::internal::NameOfEnum(
    Operand_Register_descriptor(), value);
}
inline bool Operand_Register_Parse(
    const ::std::string& name, Operand_Register* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Operand_Register>(
    Operand_Register_descriptor(), name, value);
}
enum Data_Type {
  Data_Type_STRING = 0,
  Data_Type_BYTES = 1
};
bool Data_Type_IsValid(int value);
const Data_Type Data_Type_Type_MIN = Data_Type_STRING;
const Data_Type Data_Type_Type_MAX = Data_Type_BYTES;
const int Data_Type_Type_ARRAYSIZE = Data_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Data_Type_descriptor();
inline const ::std::string& Data_Type_Name(Data_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Data_Type_descriptor(), value);
}
inline bool Data_Type_Parse(
    const ::std::string& name, Data_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Data_Type>(
    Data_Type_descriptor(), name, value);
}
// ===================================================================

class Program : public ::google::protobuf::Message {
 public:
  Program();
  virtual ~Program();
  
  Program(const Program& from);
  
  inline Program& operator=(const Program& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Program& default_instance();
  
  void Swap(Program* other);
  
  // implements Message ----------------------------------------------
  
  Program* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Program& from);
  void MergeFrom(const Program& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes assembled = 1;
  inline bool has_assembled() const;
  inline void clear_assembled();
  static const int kAssembledFieldNumber = 1;
  inline const ::std::string& assembled() const;
  inline void set_assembled(const ::std::string& value);
  inline void set_assembled(const char* value);
  inline void set_assembled(const void* value, size_t size);
  inline ::std::string* mutable_assembled();
  inline ::std::string* release_assembled();
  
  // repeated .Statement statement = 2;
  inline int statement_size() const;
  inline void clear_statement();
  static const int kStatementFieldNumber = 2;
  inline const ::Statement& statement(int index) const;
  inline ::Statement* mutable_statement(int index);
  inline ::Statement* add_statement();
  inline const ::google::protobuf::RepeatedPtrField< ::Statement >&
      statement() const;
  inline ::google::protobuf::RepeatedPtrField< ::Statement >*
      mutable_statement();
  
  // @@protoc_insertion_point(class_scope:Program)
 private:
  inline void set_has_assembled();
  inline void clear_has_assembled();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* assembled_;
  ::google::protobuf::RepeatedPtrField< ::Statement > statement_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_program_2eproto();
  friend void protobuf_AssignDesc_program_2eproto();
  friend void protobuf_ShutdownFile_program_2eproto();
  
  void InitAsDefaultInstance();
  static Program* default_instance_;
};
// -------------------------------------------------------------------

class Statement : public ::google::protobuf::Message {
 public:
  Statement();
  virtual ~Statement();
  
  Statement(const Statement& from);
  
  inline Statement& operator=(const Statement& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Statement& default_instance();
  
  void Swap(Statement* other);
  
  // implements Message ----------------------------------------------
  
  Statement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Statement& from);
  void MergeFrom(const Statement& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Statement_Type Type;
  static const Type INSTRUCTION = Statement_Type_INSTRUCTION;
  static const Type LABEL = Statement_Type_LABEL;
  static const Type DATA = Statement_Type_DATA;
  static const Type COMMENT = Statement_Type_COMMENT;
  static const Type BLANK_SPACE = Statement_Type_BLANK_SPACE;
  static inline bool Type_IsValid(int value) {
    return Statement_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Statement_Type_Type_MIN;
  static const Type Type_MAX =
    Statement_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Statement_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Statement_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Statement_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Statement_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .Statement.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::Statement_Type type() const;
  inline void set_type(::Statement_Type value);
  
  // optional .Instruction instruction = 2;
  inline bool has_instruction() const;
  inline void clear_instruction();
  static const int kInstructionFieldNumber = 2;
  inline const ::Instruction& instruction() const;
  inline ::Instruction* mutable_instruction();
  inline ::Instruction* release_instruction();
  
  // optional string label = 3;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 3;
  inline const ::std::string& label() const;
  inline void set_label(const ::std::string& value);
  inline void set_label(const char* value);
  inline void set_label(const char* value, size_t size);
  inline ::std::string* mutable_label();
  inline ::std::string* release_label();
  
  // optional .Data data = 4;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::Data& data() const;
  inline ::Data* mutable_data();
  inline ::Data* release_data();
  
  // optional string comment = 5;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 5;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  
  // optional uint32 space = 6;
  inline bool has_space() const;
  inline void clear_space();
  static const int kSpaceFieldNumber = 6;
  inline ::google::protobuf::uint32 space() const;
  inline void set_space(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:Statement)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_instruction();
  inline void clear_has_instruction();
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_space();
  inline void clear_has_space();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::Instruction* instruction_;
  ::std::string* label_;
  int type_;
  ::google::protobuf::uint32 space_;
  ::Data* data_;
  ::std::string* comment_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_program_2eproto();
  friend void protobuf_AssignDesc_program_2eproto();
  friend void protobuf_ShutdownFile_program_2eproto();
  
  void InitAsDefaultInstance();
  static Statement* default_instance_;
};
// -------------------------------------------------------------------

class Instruction : public ::google::protobuf::Message {
 public:
  Instruction();
  virtual ~Instruction();
  
  Instruction(const Instruction& from);
  
  inline Instruction& operator=(const Instruction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Instruction& default_instance();
  
  void Swap(Instruction* other);
  
  // implements Message ----------------------------------------------
  
  Instruction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Instruction& from);
  void MergeFrom(const Instruction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .Opcode opcode = 1;
  inline bool has_opcode() const;
  inline void clear_opcode();
  static const int kOpcodeFieldNumber = 1;
  inline const ::Opcode& opcode() const;
  inline ::Opcode* mutable_opcode();
  inline ::Opcode* release_opcode();
  
  // optional .Operand operand_b = 2;
  inline bool has_operand_b() const;
  inline void clear_operand_b();
  static const int kOperandBFieldNumber = 2;
  inline const ::Operand& operand_b() const;
  inline ::Operand* mutable_operand_b();
  inline ::Operand* release_operand_b();
  
  // optional .Operand operand_a = 3;
  inline bool has_operand_a() const;
  inline void clear_operand_a();
  static const int kOperandAFieldNumber = 3;
  inline const ::Operand& operand_a() const;
  inline ::Operand* mutable_operand_a();
  inline ::Operand* release_operand_a();
  
  // @@protoc_insertion_point(class_scope:Instruction)
 private:
  inline void set_has_opcode();
  inline void clear_has_opcode();
  inline void set_has_operand_b();
  inline void clear_has_operand_b();
  inline void set_has_operand_a();
  inline void clear_has_operand_a();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::Opcode* opcode_;
  ::Operand* operand_b_;
  ::Operand* operand_a_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_program_2eproto();
  friend void protobuf_AssignDesc_program_2eproto();
  friend void protobuf_ShutdownFile_program_2eproto();
  
  void InitAsDefaultInstance();
  static Instruction* default_instance_;
};
// -------------------------------------------------------------------

class Opcode : public ::google::protobuf::Message {
 public:
  Opcode();
  virtual ~Opcode();
  
  Opcode(const Opcode& from);
  
  inline Opcode& operator=(const Opcode& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Opcode& default_instance();
  
  void Swap(Opcode* other);
  
  // implements Message ----------------------------------------------
  
  Opcode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Opcode& from);
  void MergeFrom(const Opcode& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Opcode_Type Type;
  static const Type BASIC = Opcode_Type_BASIC;
  static const Type ADVANCED = Opcode_Type_ADVANCED;
  static inline bool Type_IsValid(int value) {
    return Opcode_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Opcode_Type_Type_MIN;
  static const Type Type_MAX =
    Opcode_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Opcode_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Opcode_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Opcode_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Opcode_Type_Parse(name, value);
  }
  
  typedef Opcode_Basic Basic;
  static const Basic SET = Opcode_Basic_SET;
  static const Basic ADD = Opcode_Basic_ADD;
  static const Basic SUB = Opcode_Basic_SUB;
  static const Basic MUL = Opcode_Basic_MUL;
  static const Basic MLI = Opcode_Basic_MLI;
  static const Basic DIV = Opcode_Basic_DIV;
  static const Basic DVI = Opcode_Basic_DVI;
  static const Basic MOD = Opcode_Basic_MOD;
  static const Basic AND = Opcode_Basic_AND;
  static const Basic BOR = Opcode_Basic_BOR;
  static const Basic XOR = Opcode_Basic_XOR;
  static const Basic SHR = Opcode_Basic_SHR;
  static const Basic ASR = Opcode_Basic_ASR;
  static const Basic SHL = Opcode_Basic_SHL;
  static const Basic MVI = Opcode_Basic_MVI;
  static const Basic IFB = Opcode_Basic_IFB;
  static const Basic IFC = Opcode_Basic_IFC;
  static const Basic IFE = Opcode_Basic_IFE;
  static const Basic IFN = Opcode_Basic_IFN;
  static const Basic IFG = Opcode_Basic_IFG;
  static const Basic IFA = Opcode_Basic_IFA;
  static const Basic IFL = Opcode_Basic_IFL;
  static const Basic IFU = Opcode_Basic_IFU;
  static const Basic ADX = Opcode_Basic_ADX;
  static const Basic SUX = Opcode_Basic_SUX;
  static inline bool Basic_IsValid(int value) {
    return Opcode_Basic_IsValid(value);
  }
  static const Basic Basic_MIN =
    Opcode_Basic_Basic_MIN;
  static const Basic Basic_MAX =
    Opcode_Basic_Basic_MAX;
  static const int Basic_ARRAYSIZE =
    Opcode_Basic_Basic_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Basic_descriptor() {
    return Opcode_Basic_descriptor();
  }
  static inline const ::std::string& Basic_Name(Basic value) {
    return Opcode_Basic_Name(value);
  }
  static inline bool Basic_Parse(const ::std::string& name,
      Basic* value) {
    return Opcode_Basic_Parse(name, value);
  }
  
  typedef Opcode_Advanced Advanced;
  static const Advanced JSR = Opcode_Advanced_JSR;
  static const Advanced INT = Opcode_Advanced_INT;
  static const Advanced IAG = Opcode_Advanced_IAG;
  static const Advanced IAS = Opcode_Advanced_IAS;
  static const Advanced HWN = Opcode_Advanced_HWN;
  static const Advanced HWQ = Opcode_Advanced_HWQ;
  static const Advanced HWI = Opcode_Advanced_HWI;
  static inline bool Advanced_IsValid(int value) {
    return Opcode_Advanced_IsValid(value);
  }
  static const Advanced Advanced_MIN =
    Opcode_Advanced_Advanced_MIN;
  static const Advanced Advanced_MAX =
    Opcode_Advanced_Advanced_MAX;
  static const int Advanced_ARRAYSIZE =
    Opcode_Advanced_Advanced_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Advanced_descriptor() {
    return Opcode_Advanced_descriptor();
  }
  static inline const ::std::string& Advanced_Name(Advanced value) {
    return Opcode_Advanced_Name(value);
  }
  static inline bool Advanced_Parse(const ::std::string& name,
      Advanced* value) {
    return Opcode_Advanced_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .Opcode.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::Opcode_Type type() const;
  inline void set_type(::Opcode_Type value);
  
  // optional .Opcode.Basic basic = 2;
  inline bool has_basic() const;
  inline void clear_basic();
  static const int kBasicFieldNumber = 2;
  inline ::Opcode_Basic basic() const;
  inline void set_basic(::Opcode_Basic value);
  
  // optional .Opcode.Advanced advanced = 3;
  inline bool has_advanced() const;
  inline void clear_advanced();
  static const int kAdvancedFieldNumber = 3;
  inline ::Opcode_Advanced advanced() const;
  inline void set_advanced(::Opcode_Advanced value);
  
  // @@protoc_insertion_point(class_scope:Opcode)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_basic();
  inline void clear_has_basic();
  inline void set_has_advanced();
  inline void clear_has_advanced();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int type_;
  int basic_;
  int advanced_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_program_2eproto();
  friend void protobuf_AssignDesc_program_2eproto();
  friend void protobuf_ShutdownFile_program_2eproto();
  
  void InitAsDefaultInstance();
  static Opcode* default_instance_;
};
// -------------------------------------------------------------------

class Operand : public ::google::protobuf::Message {
 public:
  Operand();
  virtual ~Operand();
  
  Operand(const Operand& from);
  
  inline Operand& operator=(const Operand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Operand& default_instance();
  
  void Swap(Operand* other);
  
  // implements Message ----------------------------------------------
  
  Operand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Operand& from);
  void MergeFrom(const Operand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Operand_Type Type;
  static const Type REGISTER = Operand_Type_REGISTER;
  static const Type LOCATION_IN_REGISTER = Operand_Type_LOCATION_IN_REGISTER;
  static const Type LOCATION_OFFSET_BY_REGISTER = Operand_Type_LOCATION_OFFSET_BY_REGISTER;
  static const Type PUSH_POP = Operand_Type_PUSH_POP;
  static const Type PEEK = Operand_Type_PEEK;
  static const Type PICK = Operand_Type_PICK;
  static const Type STACK_POINTER = Operand_Type_STACK_POINTER;
  static const Type PROGRAM_COUNTER = Operand_Type_PROGRAM_COUNTER;
  static const Type EXTRA = Operand_Type_EXTRA;
  static const Type LOCATION = Operand_Type_LOCATION;
  static const Type LITERAL = Operand_Type_LITERAL;
  static inline bool Type_IsValid(int value) {
    return Operand_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Operand_Type_Type_MIN;
  static const Type Type_MAX =
    Operand_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Operand_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Operand_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Operand_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Operand_Type_Parse(name, value);
  }
  
  typedef Operand_Register Register;
  static const Register A = Operand_Register_A;
  static const Register B = Operand_Register_B;
  static const Register C = Operand_Register_C;
  static const Register X = Operand_Register_X;
  static const Register Y = Operand_Register_Y;
  static const Register Z = Operand_Register_Z;
  static const Register I = Operand_Register_I;
  static const Register J = Operand_Register_J;
  static inline bool Register_IsValid(int value) {
    return Operand_Register_IsValid(value);
  }
  static const Register Register_MIN =
    Operand_Register_Register_MIN;
  static const Register Register_MAX =
    Operand_Register_Register_MAX;
  static const int Register_ARRAYSIZE =
    Operand_Register_Register_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Register_descriptor() {
    return Operand_Register_descriptor();
  }
  static inline const ::std::string& Register_Name(Register value) {
    return Operand_Register_Name(value);
  }
  static inline bool Register_Parse(const ::std::string& name,
      Register* value) {
    return Operand_Register_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .Operand.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::Operand_Type type() const;
  inline void set_type(::Operand_Type value);
  
  // optional .Operand.Register register = 2;
  inline bool has_register_() const;
  inline void clear_register_();
  static const int kRegisterFieldNumber = 2;
  inline ::Operand_Register register_() const;
  inline void set_register_(::Operand_Register value);
  
  // optional sint32 value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);
  
  // optional string label = 4;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 4;
  inline const ::std::string& label() const;
  inline void set_label(const ::std::string& value);
  inline void set_label(const char* value);
  inline void set_label(const char* value, size_t size);
  inline ::std::string* mutable_label();
  inline ::std::string* release_label();
  
  // @@protoc_insertion_point(class_scope:Operand)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_register_();
  inline void clear_has_register_();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_label();
  inline void clear_has_label();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int type_;
  int register__;
  ::std::string* label_;
  ::google::protobuf::int32 value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_program_2eproto();
  friend void protobuf_AssignDesc_program_2eproto();
  friend void protobuf_ShutdownFile_program_2eproto();
  
  void InitAsDefaultInstance();
  static Operand* default_instance_;
};
// -------------------------------------------------------------------

class Data : public ::google::protobuf::Message {
 public:
  Data();
  virtual ~Data();
  
  Data(const Data& from);
  
  inline Data& operator=(const Data& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Data& default_instance();
  
  void Swap(Data* other);
  
  // implements Message ----------------------------------------------
  
  Data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Data& from);
  void MergeFrom(const Data& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Data_Type Type;
  static const Type STRING = Data_Type_STRING;
  static const Type BYTES = Data_Type_BYTES;
  static inline bool Type_IsValid(int value) {
    return Data_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Data_Type_Type_MIN;
  static const Type Type_MAX =
    Data_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Data_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Data_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Data_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Data_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .Data.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::Data_Type type() const;
  inline void set_type(::Data_Type value);
  
  // optional string string = 2;
  inline bool has_string() const;
  inline void clear_string();
  static const int kStringFieldNumber = 2;
  inline const ::std::string& string() const;
  inline void set_string(const ::std::string& value);
  inline void set_string(const char* value);
  inline void set_string(const char* value, size_t size);
  inline ::std::string* mutable_string();
  inline ::std::string* release_string();
  
  // optional bytes bytes = 3;
  inline bool has_bytes() const;
  inline void clear_bytes();
  static const int kBytesFieldNumber = 3;
  inline const ::std::string& bytes() const;
  inline void set_bytes(const ::std::string& value);
  inline void set_bytes(const char* value);
  inline void set_bytes(const void* value, size_t size);
  inline ::std::string* mutable_bytes();
  inline ::std::string* release_bytes();
  
  // @@protoc_insertion_point(class_scope:Data)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_string();
  inline void clear_has_string();
  inline void set_has_bytes();
  inline void clear_has_bytes();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* string_;
  ::std::string* bytes_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_program_2eproto();
  friend void protobuf_AssignDesc_program_2eproto();
  friend void protobuf_ShutdownFile_program_2eproto();
  
  void InitAsDefaultInstance();
  static Data* default_instance_;
};
// ===================================================================


// ===================================================================

// Program

// optional bytes assembled = 1;
inline bool Program::has_assembled() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Program::set_has_assembled() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Program::clear_has_assembled() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Program::clear_assembled() {
  if (assembled_ != &::google::protobuf::internal::kEmptyString) {
    assembled_->clear();
  }
  clear_has_assembled();
}
inline const ::std::string& Program::assembled() const {
  return *assembled_;
}
inline void Program::set_assembled(const ::std::string& value) {
  set_has_assembled();
  if (assembled_ == &::google::protobuf::internal::kEmptyString) {
    assembled_ = new ::std::string;
  }
  assembled_->assign(value);
}
inline void Program::set_assembled(const char* value) {
  set_has_assembled();
  if (assembled_ == &::google::protobuf::internal::kEmptyString) {
    assembled_ = new ::std::string;
  }
  assembled_->assign(value);
}
inline void Program::set_assembled(const void* value, size_t size) {
  set_has_assembled();
  if (assembled_ == &::google::protobuf::internal::kEmptyString) {
    assembled_ = new ::std::string;
  }
  assembled_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Program::mutable_assembled() {
  set_has_assembled();
  if (assembled_ == &::google::protobuf::internal::kEmptyString) {
    assembled_ = new ::std::string;
  }
  return assembled_;
}
inline ::std::string* Program::release_assembled() {
  clear_has_assembled();
  if (assembled_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = assembled_;
    assembled_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .Statement statement = 2;
inline int Program::statement_size() const {
  return statement_.size();
}
inline void Program::clear_statement() {
  statement_.Clear();
}
inline const ::Statement& Program::statement(int index) const {
  return statement_.Get(index);
}
inline ::Statement* Program::mutable_statement(int index) {
  return statement_.Mutable(index);
}
inline ::Statement* Program::add_statement() {
  return statement_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Statement >&
Program::statement() const {
  return statement_;
}
inline ::google::protobuf::RepeatedPtrField< ::Statement >*
Program::mutable_statement() {
  return &statement_;
}

// -------------------------------------------------------------------

// Statement

// optional .Statement.Type type = 1;
inline bool Statement::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Statement::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Statement::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Statement::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Statement_Type Statement::type() const {
  return static_cast< ::Statement_Type >(type_);
}
inline void Statement::set_type(::Statement_Type value) {
  GOOGLE_DCHECK(::Statement_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .Instruction instruction = 2;
inline bool Statement::has_instruction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Statement::set_has_instruction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Statement::clear_has_instruction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Statement::clear_instruction() {
  if (instruction_ != NULL) instruction_->::Instruction::Clear();
  clear_has_instruction();
}
inline const ::Instruction& Statement::instruction() const {
  return instruction_ != NULL ? *instruction_ : *default_instance_->instruction_;
}
inline ::Instruction* Statement::mutable_instruction() {
  set_has_instruction();
  if (instruction_ == NULL) instruction_ = new ::Instruction;
  return instruction_;
}
inline ::Instruction* Statement::release_instruction() {
  clear_has_instruction();
  ::Instruction* temp = instruction_;
  instruction_ = NULL;
  return temp;
}

// optional string label = 3;
inline bool Statement::has_label() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Statement::set_has_label() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Statement::clear_has_label() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Statement::clear_label() {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    label_->clear();
  }
  clear_has_label();
}
inline const ::std::string& Statement::label() const {
  return *label_;
}
inline void Statement::set_label(const ::std::string& value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void Statement::set_label(const char* value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void Statement::set_label(const char* value, size_t size) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Statement::mutable_label() {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  return label_;
}
inline ::std::string* Statement::release_label() {
  clear_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = label_;
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .Data data = 4;
inline bool Statement::has_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Statement::set_has_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Statement::clear_has_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Statement::clear_data() {
  if (data_ != NULL) data_->::Data::Clear();
  clear_has_data();
}
inline const ::Data& Statement::data() const {
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::Data* Statement::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::Data;
  return data_;
}
inline ::Data* Statement::release_data() {
  clear_has_data();
  ::Data* temp = data_;
  data_ = NULL;
  return temp;
}

// optional string comment = 5;
inline bool Statement::has_comment() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Statement::set_has_comment() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Statement::clear_has_comment() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Statement::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& Statement::comment() const {
  return *comment_;
}
inline void Statement::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void Statement::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void Statement::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Statement::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* Statement::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 space = 6;
inline bool Statement::has_space() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Statement::set_has_space() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Statement::clear_has_space() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Statement::clear_space() {
  space_ = 0u;
  clear_has_space();
}
inline ::google::protobuf::uint32 Statement::space() const {
  return space_;
}
inline void Statement::set_space(::google::protobuf::uint32 value) {
  set_has_space();
  space_ = value;
}

// -------------------------------------------------------------------

// Instruction

// optional .Opcode opcode = 1;
inline bool Instruction::has_opcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Instruction::set_has_opcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Instruction::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Instruction::clear_opcode() {
  if (opcode_ != NULL) opcode_->::Opcode::Clear();
  clear_has_opcode();
}
inline const ::Opcode& Instruction::opcode() const {
  return opcode_ != NULL ? *opcode_ : *default_instance_->opcode_;
}
inline ::Opcode* Instruction::mutable_opcode() {
  set_has_opcode();
  if (opcode_ == NULL) opcode_ = new ::Opcode;
  return opcode_;
}
inline ::Opcode* Instruction::release_opcode() {
  clear_has_opcode();
  ::Opcode* temp = opcode_;
  opcode_ = NULL;
  return temp;
}

// optional .Operand operand_b = 2;
inline bool Instruction::has_operand_b() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Instruction::set_has_operand_b() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Instruction::clear_has_operand_b() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Instruction::clear_operand_b() {
  if (operand_b_ != NULL) operand_b_->::Operand::Clear();
  clear_has_operand_b();
}
inline const ::Operand& Instruction::operand_b() const {
  return operand_b_ != NULL ? *operand_b_ : *default_instance_->operand_b_;
}
inline ::Operand* Instruction::mutable_operand_b() {
  set_has_operand_b();
  if (operand_b_ == NULL) operand_b_ = new ::Operand;
  return operand_b_;
}
inline ::Operand* Instruction::release_operand_b() {
  clear_has_operand_b();
  ::Operand* temp = operand_b_;
  operand_b_ = NULL;
  return temp;
}

// optional .Operand operand_a = 3;
inline bool Instruction::has_operand_a() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Instruction::set_has_operand_a() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Instruction::clear_has_operand_a() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Instruction::clear_operand_a() {
  if (operand_a_ != NULL) operand_a_->::Operand::Clear();
  clear_has_operand_a();
}
inline const ::Operand& Instruction::operand_a() const {
  return operand_a_ != NULL ? *operand_a_ : *default_instance_->operand_a_;
}
inline ::Operand* Instruction::mutable_operand_a() {
  set_has_operand_a();
  if (operand_a_ == NULL) operand_a_ = new ::Operand;
  return operand_a_;
}
inline ::Operand* Instruction::release_operand_a() {
  clear_has_operand_a();
  ::Operand* temp = operand_a_;
  operand_a_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Opcode

// optional .Opcode.Type type = 1;
inline bool Opcode::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Opcode::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Opcode::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Opcode::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Opcode_Type Opcode::type() const {
  return static_cast< ::Opcode_Type >(type_);
}
inline void Opcode::set_type(::Opcode_Type value) {
  GOOGLE_DCHECK(::Opcode_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .Opcode.Basic basic = 2;
inline bool Opcode::has_basic() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Opcode::set_has_basic() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Opcode::clear_has_basic() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Opcode::clear_basic() {
  basic_ = 1;
  clear_has_basic();
}
inline ::Opcode_Basic Opcode::basic() const {
  return static_cast< ::Opcode_Basic >(basic_);
}
inline void Opcode::set_basic(::Opcode_Basic value) {
  GOOGLE_DCHECK(::Opcode_Basic_IsValid(value));
  set_has_basic();
  basic_ = value;
}

// optional .Opcode.Advanced advanced = 3;
inline bool Opcode::has_advanced() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Opcode::set_has_advanced() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Opcode::clear_has_advanced() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Opcode::clear_advanced() {
  advanced_ = 1;
  clear_has_advanced();
}
inline ::Opcode_Advanced Opcode::advanced() const {
  return static_cast< ::Opcode_Advanced >(advanced_);
}
inline void Opcode::set_advanced(::Opcode_Advanced value) {
  GOOGLE_DCHECK(::Opcode_Advanced_IsValid(value));
  set_has_advanced();
  advanced_ = value;
}

// -------------------------------------------------------------------

// Operand

// optional .Operand.Type type = 1;
inline bool Operand::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Operand::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Operand::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Operand::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Operand_Type Operand::type() const {
  return static_cast< ::Operand_Type >(type_);
}
inline void Operand::set_type(::Operand_Type value) {
  GOOGLE_DCHECK(::Operand_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .Operand.Register register = 2;
inline bool Operand::has_register_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Operand::set_has_register_() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Operand::clear_has_register_() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Operand::clear_register_() {
  register__ = 0;
  clear_has_register_();
}
inline ::Operand_Register Operand::register_() const {
  return static_cast< ::Operand_Register >(register__);
}
inline void Operand::set_register_(::Operand_Register value) {
  GOOGLE_DCHECK(::Operand_Register_IsValid(value));
  set_has_register_();
  register__ = value;
}

// optional sint32 value = 3;
inline bool Operand::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Operand::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Operand::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Operand::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 Operand::value() const {
  return value_;
}
inline void Operand::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
}

// optional string label = 4;
inline bool Operand::has_label() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Operand::set_has_label() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Operand::clear_has_label() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Operand::clear_label() {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    label_->clear();
  }
  clear_has_label();
}
inline const ::std::string& Operand::label() const {
  return *label_;
}
inline void Operand::set_label(const ::std::string& value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void Operand::set_label(const char* value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void Operand::set_label(const char* value, size_t size) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Operand::mutable_label() {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  return label_;
}
inline ::std::string* Operand::release_label() {
  clear_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = label_;
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Data

// optional .Data.Type type = 1;
inline bool Data::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Data::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Data::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Data::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Data_Type Data::type() const {
  return static_cast< ::Data_Type >(type_);
}
inline void Data::set_type(::Data_Type value) {
  GOOGLE_DCHECK(::Data_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string string = 2;
inline bool Data::has_string() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Data::set_has_string() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Data::clear_has_string() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Data::clear_string() {
  if (string_ != &::google::protobuf::internal::kEmptyString) {
    string_->clear();
  }
  clear_has_string();
}
inline const ::std::string& Data::string() const {
  return *string_;
}
inline void Data::set_string(const ::std::string& value) {
  set_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    string_ = new ::std::string;
  }
  string_->assign(value);
}
inline void Data::set_string(const char* value) {
  set_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    string_ = new ::std::string;
  }
  string_->assign(value);
}
inline void Data::set_string(const char* value, size_t size) {
  set_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    string_ = new ::std::string;
  }
  string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Data::mutable_string() {
  set_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    string_ = new ::std::string;
  }
  return string_;
}
inline ::std::string* Data::release_string() {
  clear_has_string();
  if (string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = string_;
    string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes bytes = 3;
inline bool Data::has_bytes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Data::set_has_bytes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Data::clear_has_bytes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Data::clear_bytes() {
  if (bytes_ != &::google::protobuf::internal::kEmptyString) {
    bytes_->clear();
  }
  clear_has_bytes();
}
inline const ::std::string& Data::bytes() const {
  return *bytes_;
}
inline void Data::set_bytes(const ::std::string& value) {
  set_has_bytes();
  if (bytes_ == &::google::protobuf::internal::kEmptyString) {
    bytes_ = new ::std::string;
  }
  bytes_->assign(value);
}
inline void Data::set_bytes(const char* value) {
  set_has_bytes();
  if (bytes_ == &::google::protobuf::internal::kEmptyString) {
    bytes_ = new ::std::string;
  }
  bytes_->assign(value);
}
inline void Data::set_bytes(const void* value, size_t size) {
  set_has_bytes();
  if (bytes_ == &::google::protobuf::internal::kEmptyString) {
    bytes_ = new ::std::string;
  }
  bytes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Data::mutable_bytes() {
  set_has_bytes();
  if (bytes_ == &::google::protobuf::internal::kEmptyString) {
    bytes_ = new ::std::string;
  }
  return bytes_;
}
inline ::std::string* Data::release_bytes() {
  clear_has_bytes();
  if (bytes_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bytes_;
    bytes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Statement_Type>() {
  return ::Statement_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Opcode_Type>() {
  return ::Opcode_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Opcode_Basic>() {
  return ::Opcode_Basic_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Opcode_Advanced>() {
  return ::Opcode_Advanced_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Operand_Type>() {
  return ::Operand_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Operand_Register>() {
  return ::Operand_Register_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Data_Type>() {
  return ::Data_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_program_2eproto__INCLUDED
