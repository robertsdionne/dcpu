// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "program.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* Program_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Program_reflection_ = NULL;
const ::google::protobuf::Descriptor* Statement_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Statement_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Statement_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Instruction_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Instruction_reflection_ = NULL;
const ::google::protobuf::Descriptor* Opcode_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Opcode_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Opcode_Type_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Opcode_Basic_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Opcode_Advanced_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Operand_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Operand_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Operand_Type_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Operand_Register_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Data_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Data_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Data_Type_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_program_2eproto() {
  protobuf_AddDesc_program_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "program.proto");
  GOOGLE_CHECK(file != NULL);
  Program_descriptor_ = file->message_type(0);
  static const int Program_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Program, assembled_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Program, statement_),
  };
  Program_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Program_descriptor_,
      Program::default_instance_,
      Program_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Program, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Program, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Program));
  Statement_descriptor_ = file->message_type(1);
  static const int Statement_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Statement, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Statement, instruction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Statement, label_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Statement, data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Statement, comment_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Statement, space_),
  };
  Statement_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Statement_descriptor_,
      Statement::default_instance_,
      Statement_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Statement, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Statement, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Statement));
  Statement_Type_descriptor_ = Statement_descriptor_->enum_type(0);
  Instruction_descriptor_ = file->message_type(2);
  static const int Instruction_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Instruction, opcode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Instruction, operand_b_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Instruction, operand_a_),
  };
  Instruction_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Instruction_descriptor_,
      Instruction::default_instance_,
      Instruction_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Instruction, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Instruction, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Instruction));
  Opcode_descriptor_ = file->message_type(3);
  static const int Opcode_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Opcode, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Opcode, basic_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Opcode, advanced_),
  };
  Opcode_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Opcode_descriptor_,
      Opcode::default_instance_,
      Opcode_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Opcode, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Opcode, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Opcode));
  Opcode_Type_descriptor_ = Opcode_descriptor_->enum_type(0);
  Opcode_Basic_descriptor_ = Opcode_descriptor_->enum_type(1);
  Opcode_Advanced_descriptor_ = Opcode_descriptor_->enum_type(2);
  Operand_descriptor_ = file->message_type(4);
  static const int Operand_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Operand, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Operand, register__),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Operand, value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Operand, label_),
  };
  Operand_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Operand_descriptor_,
      Operand::default_instance_,
      Operand_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Operand, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Operand, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Operand));
  Operand_Type_descriptor_ = Operand_descriptor_->enum_type(0);
  Operand_Register_descriptor_ = Operand_descriptor_->enum_type(1);
  Data_descriptor_ = file->message_type(5);
  static const int Data_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Data, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Data, string_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Data, bytes_),
  };
  Data_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Data_descriptor_,
      Data::default_instance_,
      Data_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Data, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Data, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Data));
  Data_Type_descriptor_ = Data_descriptor_->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_program_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Program_descriptor_, &Program::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Statement_descriptor_, &Statement::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Instruction_descriptor_, &Instruction::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Opcode_descriptor_, &Opcode::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Operand_descriptor_, &Operand::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Data_descriptor_, &Data::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_program_2eproto() {
  delete Program::default_instance_;
  delete Program_reflection_;
  delete Statement::default_instance_;
  delete Statement_reflection_;
  delete Instruction::default_instance_;
  delete Instruction_reflection_;
  delete Opcode::default_instance_;
  delete Opcode_reflection_;
  delete Operand::default_instance_;
  delete Operand_reflection_;
  delete Data::default_instance_;
  delete Data_reflection_;
}

void protobuf_AddDesc_program_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\rprogram.proto\";\n\007Program\022\021\n\tassembled\030"
    "\001 \001(\014\022\035\n\tstatement\030\002 \003(\0132\n.Statement\"\335\001\n"
    "\tStatement\022\035\n\004type\030\001 \001(\0162\017.Statement.Typ"
    "e\022!\n\013instruction\030\002 \001(\0132\014.Instruction\022\r\n\005"
    "label\030\003 \001(\t\022\023\n\004data\030\004 \001(\0132\005.Data\022\017\n\007comm"
    "ent\030\005 \001(\t\022\r\n\005space\030\006 \001(\r\"J\n\004Type\022\017\n\013INST"
    "RUCTION\020\000\022\t\n\005LABEL\020\001\022\010\n\004DATA\020\002\022\013\n\007COMMEN"
    "T\020\003\022\017\n\013BLANK_SPACE\020\004\"`\n\013Instruction\022\027\n\006o"
    "pcode\030\001 \001(\0132\007.Opcode\022\033\n\toperand_b\030\002 \001(\0132"
    "\010.Operand\022\033\n\toperand_a\030\003 \001(\0132\010.Operand\"\275"
    "\003\n\006Opcode\022\032\n\004type\030\001 \001(\0162\014.Opcode.Type\022\034\n"
    "\005basic\030\002 \001(\0162\r.Opcode.Basic\022\"\n\010advanced\030"
    "\003 \001(\0162\020.Opcode.Advanced\"\037\n\004Type\022\t\n\005BASIC"
    "\020\000\022\014\n\010ADVANCED\020\001\"\350\001\n\005Basic\022\007\n\003SET\020\001\022\007\n\003A"
    "DD\020\002\022\007\n\003SUB\020\003\022\007\n\003MUL\020\004\022\007\n\003MLI\020\005\022\007\n\003DIV\020\006"
    "\022\007\n\003DVI\020\007\022\007\n\003MOD\020\010\022\007\n\003AND\020\t\022\007\n\003BOR\020\n\022\007\n\003"
    "XOR\020\013\022\007\n\003SHR\020\014\022\007\n\003ASR\020\r\022\007\n\003SHL\020\016\022\007\n\003MVI\020"
    "\017\022\007\n\003IFB\020\020\022\007\n\003IFC\020\021\022\007\n\003IFE\020\022\022\007\n\003IFN\020\023\022\007\n"
    "\003IFG\020\024\022\007\n\003IFA\020\025\022\007\n\003IFL\020\026\022\007\n\003IFU\020\027\022\007\n\003ADX"
    "\020\032\022\007\n\003SUX\020\033\"I\n\010Advanced\022\007\n\003JSR\020\001\022\007\n\003INT\020"
    "\010\022\007\n\003IAG\020\t\022\007\n\003IAS\020\n\022\007\n\003HWN\020\020\022\007\n\003HWQ\020\021\022\007\n"
    "\003HWI\020\022\"\357\002\n\007Operand\022\033\n\004type\030\001 \001(\0162\r.Opera"
    "nd.Type\022#\n\010register\030\002 \001(\0162\021.Operand.Regi"
    "ster\022\r\n\005value\030\003 \001(\021\022\r\n\005label\030\004 \001(\t\"\277\001\n\004T"
    "ype\022\014\n\010REGISTER\020\000\022\030\n\024LOCATION_IN_REGISTE"
    "R\020\010\022\037\n\033LOCATION_OFFSET_BY_REGISTER\020\020\022\014\n\010"
    "PUSH_POP\020\030\022\010\n\004PEEK\020\031\022\010\n\004PICK\020\032\022\021\n\rSTACK_"
    "POINTER\020\033\022\023\n\017PROGRAM_COUNTER\020\034\022\t\n\005EXTRA\020"
    "\035\022\014\n\010LOCATION\020\036\022\013\n\007LITERAL\020\037\"B\n\010Register"
    "\022\005\n\001A\020\000\022\005\n\001B\020\001\022\005\n\001C\020\002\022\005\n\001X\020\003\022\005\n\001Y\020\004\022\005\n\001Z"
    "\020\005\022\005\n\001I\020\006\022\005\n\001J\020\007\"^\n\004Data\022\030\n\004type\030\001 \001(\0162\n"
    ".Data.Type\022\016\n\006string\030\002 \001(\t\022\r\n\005bytes\030\003 \001("
    "\014\"\035\n\004Type\022\n\n\006STRING\020\000\022\t\n\005BYTES\020\001", 1312);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "program.proto", &protobuf_RegisterTypes);
  Program::default_instance_ = new Program();
  Statement::default_instance_ = new Statement();
  Instruction::default_instance_ = new Instruction();
  Opcode::default_instance_ = new Opcode();
  Operand::default_instance_ = new Operand();
  Data::default_instance_ = new Data();
  Program::default_instance_->InitAsDefaultInstance();
  Statement::default_instance_->InitAsDefaultInstance();
  Instruction::default_instance_->InitAsDefaultInstance();
  Opcode::default_instance_->InitAsDefaultInstance();
  Operand::default_instance_->InitAsDefaultInstance();
  Data::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_program_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_program_2eproto {
  StaticDescriptorInitializer_program_2eproto() {
    protobuf_AddDesc_program_2eproto();
  }
} static_descriptor_initializer_program_2eproto_;


// ===================================================================

#ifndef _MSC_VER
const int Program::kAssembledFieldNumber;
const int Program::kStatementFieldNumber;
#endif  // !_MSC_VER

Program::Program()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Program::InitAsDefaultInstance() {
}

Program::Program(const Program& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Program::SharedCtor() {
  _cached_size_ = 0;
  assembled_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Program::~Program() {
  SharedDtor();
}

void Program::SharedDtor() {
  if (assembled_ != &::google::protobuf::internal::kEmptyString) {
    delete assembled_;
  }
  if (this != default_instance_) {
  }
}

void Program::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Program::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Program_descriptor_;
}

const Program& Program::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_program_2eproto();  return *default_instance_;
}

Program* Program::default_instance_ = NULL;

Program* Program::New() const {
  return new Program;
}

void Program::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_assembled()) {
      if (assembled_ != &::google::protobuf::internal::kEmptyString) {
        assembled_->clear();
      }
    }
  }
  statement_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Program::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes assembled = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_assembled()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_statement;
        break;
      }
      
      // repeated .Statement statement = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_statement:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_statement()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_statement;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Program::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes assembled = 1;
  if (has_assembled()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->assembled(), output);
  }
  
  // repeated .Statement statement = 2;
  for (int i = 0; i < this->statement_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->statement(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Program::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes assembled = 1;
  if (has_assembled()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->assembled(), target);
  }
  
  // repeated .Statement statement = 2;
  for (int i = 0; i < this->statement_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->statement(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Program::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes assembled = 1;
    if (has_assembled()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->assembled());
    }
    
  }
  // repeated .Statement statement = 2;
  total_size += 1 * this->statement_size();
  for (int i = 0; i < this->statement_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->statement(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Program::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Program* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Program*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Program::MergeFrom(const Program& from) {
  GOOGLE_CHECK_NE(&from, this);
  statement_.MergeFrom(from.statement_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_assembled()) {
      set_assembled(from.assembled());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Program::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Program::CopyFrom(const Program& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Program::IsInitialized() const {
  
  return true;
}

void Program::Swap(Program* other) {
  if (other != this) {
    std::swap(assembled_, other->assembled_);
    statement_.Swap(&other->statement_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Program::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Program_descriptor_;
  metadata.reflection = Program_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Statement_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Statement_Type_descriptor_;
}
bool Statement_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Statement_Type Statement::INSTRUCTION;
const Statement_Type Statement::LABEL;
const Statement_Type Statement::DATA;
const Statement_Type Statement::COMMENT;
const Statement_Type Statement::BLANK_SPACE;
const Statement_Type Statement::Type_MIN;
const Statement_Type Statement::Type_MAX;
const int Statement::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Statement::kTypeFieldNumber;
const int Statement::kInstructionFieldNumber;
const int Statement::kLabelFieldNumber;
const int Statement::kDataFieldNumber;
const int Statement::kCommentFieldNumber;
const int Statement::kSpaceFieldNumber;
#endif  // !_MSC_VER

Statement::Statement()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Statement::InitAsDefaultInstance() {
  instruction_ = const_cast< ::Instruction*>(&::Instruction::default_instance());
  data_ = const_cast< ::Data*>(&::Data::default_instance());
}

Statement::Statement(const Statement& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Statement::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  instruction_ = NULL;
  label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  data_ = NULL;
  comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  space_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Statement::~Statement() {
  SharedDtor();
}

void Statement::SharedDtor() {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    delete label_;
  }
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    delete comment_;
  }
  if (this != default_instance_) {
    delete instruction_;
    delete data_;
  }
}

void Statement::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Statement::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Statement_descriptor_;
}

const Statement& Statement::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_program_2eproto();  return *default_instance_;
}

Statement* Statement::default_instance_ = NULL;

Statement* Statement::New() const {
  return new Statement;
}

void Statement::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    if (has_instruction()) {
      if (instruction_ != NULL) instruction_->::Instruction::Clear();
    }
    if (has_label()) {
      if (label_ != &::google::protobuf::internal::kEmptyString) {
        label_->clear();
      }
    }
    if (has_data()) {
      if (data_ != NULL) data_->::Data::Clear();
    }
    if (has_comment()) {
      if (comment_ != &::google::protobuf::internal::kEmptyString) {
        comment_->clear();
      }
    }
    space_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Statement::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Statement.Type type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Statement_Type_IsValid(value)) {
            set_type(static_cast< ::Statement_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_instruction;
        break;
      }
      
      // optional .Instruction instruction = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_instruction:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_instruction()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_label;
        break;
      }
      
      // optional string label = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_label:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_label()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->label().data(), this->label().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_data;
        break;
      }
      
      // optional .Data data = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_comment;
        break;
      }
      
      // optional string comment = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_comment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_comment()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->comment().data(), this->comment().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_space;
        break;
      }
      
      // optional uint32 space = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_space:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &space_)));
          set_has_space();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Statement::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Statement.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }
  
  // optional .Instruction instruction = 2;
  if (has_instruction()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->instruction(), output);
  }
  
  // optional string label = 3;
  if (has_label()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->label().data(), this->label().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->label(), output);
  }
  
  // optional .Data data = 4;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->data(), output);
  }
  
  // optional string comment = 5;
  if (has_comment()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->comment().data(), this->comment().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->comment(), output);
  }
  
  // optional uint32 space = 6;
  if (has_space()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->space(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Statement::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .Statement.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }
  
  // optional .Instruction instruction = 2;
  if (has_instruction()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->instruction(), target);
  }
  
  // optional string label = 3;
  if (has_label()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->label().data(), this->label().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->label(), target);
  }
  
  // optional .Data data = 4;
  if (has_data()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->data(), target);
  }
  
  // optional string comment = 5;
  if (has_comment()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->comment().data(), this->comment().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->comment(), target);
  }
  
  // optional uint32 space = 6;
  if (has_space()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->space(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Statement::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Statement.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }
    
    // optional .Instruction instruction = 2;
    if (has_instruction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->instruction());
    }
    
    // optional string label = 3;
    if (has_label()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->label());
    }
    
    // optional .Data data = 4;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->data());
    }
    
    // optional string comment = 5;
    if (has_comment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->comment());
    }
    
    // optional uint32 space = 6;
    if (has_space()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->space());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Statement::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Statement* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Statement*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Statement::MergeFrom(const Statement& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_instruction()) {
      mutable_instruction()->::Instruction::MergeFrom(from.instruction());
    }
    if (from.has_label()) {
      set_label(from.label());
    }
    if (from.has_data()) {
      mutable_data()->::Data::MergeFrom(from.data());
    }
    if (from.has_comment()) {
      set_comment(from.comment());
    }
    if (from.has_space()) {
      set_space(from.space());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Statement::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Statement::CopyFrom(const Statement& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Statement::IsInitialized() const {
  
  return true;
}

void Statement::Swap(Statement* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(instruction_, other->instruction_);
    std::swap(label_, other->label_);
    std::swap(data_, other->data_);
    std::swap(comment_, other->comment_);
    std::swap(space_, other->space_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Statement::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Statement_descriptor_;
  metadata.reflection = Statement_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Instruction::kOpcodeFieldNumber;
const int Instruction::kOperandBFieldNumber;
const int Instruction::kOperandAFieldNumber;
#endif  // !_MSC_VER

Instruction::Instruction()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Instruction::InitAsDefaultInstance() {
  opcode_ = const_cast< ::Opcode*>(&::Opcode::default_instance());
  operand_b_ = const_cast< ::Operand*>(&::Operand::default_instance());
  operand_a_ = const_cast< ::Operand*>(&::Operand::default_instance());
}

Instruction::Instruction(const Instruction& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Instruction::SharedCtor() {
  _cached_size_ = 0;
  opcode_ = NULL;
  operand_b_ = NULL;
  operand_a_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Instruction::~Instruction() {
  SharedDtor();
}

void Instruction::SharedDtor() {
  if (this != default_instance_) {
    delete opcode_;
    delete operand_b_;
    delete operand_a_;
  }
}

void Instruction::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Instruction::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Instruction_descriptor_;
}

const Instruction& Instruction::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_program_2eproto();  return *default_instance_;
}

Instruction* Instruction::default_instance_ = NULL;

Instruction* Instruction::New() const {
  return new Instruction;
}

void Instruction::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_opcode()) {
      if (opcode_ != NULL) opcode_->::Opcode::Clear();
    }
    if (has_operand_b()) {
      if (operand_b_ != NULL) operand_b_->::Operand::Clear();
    }
    if (has_operand_a()) {
      if (operand_a_ != NULL) operand_a_->::Operand::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Instruction::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Opcode opcode = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_opcode()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_operand_b;
        break;
      }
      
      // optional .Operand operand_b = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_operand_b:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_operand_b()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_operand_a;
        break;
      }
      
      // optional .Operand operand_a = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_operand_a:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_operand_a()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Instruction::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Opcode opcode = 1;
  if (has_opcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->opcode(), output);
  }
  
  // optional .Operand operand_b = 2;
  if (has_operand_b()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->operand_b(), output);
  }
  
  // optional .Operand operand_a = 3;
  if (has_operand_a()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->operand_a(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Instruction::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .Opcode opcode = 1;
  if (has_opcode()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->opcode(), target);
  }
  
  // optional .Operand operand_b = 2;
  if (has_operand_b()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->operand_b(), target);
  }
  
  // optional .Operand operand_a = 3;
  if (has_operand_a()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->operand_a(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Instruction::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Opcode opcode = 1;
    if (has_opcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->opcode());
    }
    
    // optional .Operand operand_b = 2;
    if (has_operand_b()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->operand_b());
    }
    
    // optional .Operand operand_a = 3;
    if (has_operand_a()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->operand_a());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Instruction::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Instruction* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Instruction*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Instruction::MergeFrom(const Instruction& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_opcode()) {
      mutable_opcode()->::Opcode::MergeFrom(from.opcode());
    }
    if (from.has_operand_b()) {
      mutable_operand_b()->::Operand::MergeFrom(from.operand_b());
    }
    if (from.has_operand_a()) {
      mutable_operand_a()->::Operand::MergeFrom(from.operand_a());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Instruction::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Instruction::CopyFrom(const Instruction& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Instruction::IsInitialized() const {
  
  return true;
}

void Instruction::Swap(Instruction* other) {
  if (other != this) {
    std::swap(opcode_, other->opcode_);
    std::swap(operand_b_, other->operand_b_);
    std::swap(operand_a_, other->operand_a_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Instruction::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Instruction_descriptor_;
  metadata.reflection = Instruction_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Opcode_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Opcode_Type_descriptor_;
}
bool Opcode_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Opcode_Type Opcode::BASIC;
const Opcode_Type Opcode::ADVANCED;
const Opcode_Type Opcode::Type_MIN;
const Opcode_Type Opcode::Type_MAX;
const int Opcode::Type_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* Opcode_Basic_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Opcode_Basic_descriptor_;
}
bool Opcode_Basic_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 26:
    case 27:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Opcode_Basic Opcode::SET;
const Opcode_Basic Opcode::ADD;
const Opcode_Basic Opcode::SUB;
const Opcode_Basic Opcode::MUL;
const Opcode_Basic Opcode::MLI;
const Opcode_Basic Opcode::DIV;
const Opcode_Basic Opcode::DVI;
const Opcode_Basic Opcode::MOD;
const Opcode_Basic Opcode::AND;
const Opcode_Basic Opcode::BOR;
const Opcode_Basic Opcode::XOR;
const Opcode_Basic Opcode::SHR;
const Opcode_Basic Opcode::ASR;
const Opcode_Basic Opcode::SHL;
const Opcode_Basic Opcode::MVI;
const Opcode_Basic Opcode::IFB;
const Opcode_Basic Opcode::IFC;
const Opcode_Basic Opcode::IFE;
const Opcode_Basic Opcode::IFN;
const Opcode_Basic Opcode::IFG;
const Opcode_Basic Opcode::IFA;
const Opcode_Basic Opcode::IFL;
const Opcode_Basic Opcode::IFU;
const Opcode_Basic Opcode::ADX;
const Opcode_Basic Opcode::SUX;
const Opcode_Basic Opcode::Basic_MIN;
const Opcode_Basic Opcode::Basic_MAX;
const int Opcode::Basic_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* Opcode_Advanced_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Opcode_Advanced_descriptor_;
}
bool Opcode_Advanced_IsValid(int value) {
  switch(value) {
    case 1:
    case 8:
    case 9:
    case 10:
    case 16:
    case 17:
    case 18:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Opcode_Advanced Opcode::JSR;
const Opcode_Advanced Opcode::INT;
const Opcode_Advanced Opcode::IAG;
const Opcode_Advanced Opcode::IAS;
const Opcode_Advanced Opcode::HWN;
const Opcode_Advanced Opcode::HWQ;
const Opcode_Advanced Opcode::HWI;
const Opcode_Advanced Opcode::Advanced_MIN;
const Opcode_Advanced Opcode::Advanced_MAX;
const int Opcode::Advanced_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Opcode::kTypeFieldNumber;
const int Opcode::kBasicFieldNumber;
const int Opcode::kAdvancedFieldNumber;
#endif  // !_MSC_VER

Opcode::Opcode()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Opcode::InitAsDefaultInstance() {
}

Opcode::Opcode(const Opcode& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Opcode::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  basic_ = 1;
  advanced_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Opcode::~Opcode() {
  SharedDtor();
}

void Opcode::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Opcode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Opcode::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Opcode_descriptor_;
}

const Opcode& Opcode::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_program_2eproto();  return *default_instance_;
}

Opcode* Opcode::default_instance_ = NULL;

Opcode* Opcode::New() const {
  return new Opcode;
}

void Opcode::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    basic_ = 1;
    advanced_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Opcode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Opcode.Type type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Opcode_Type_IsValid(value)) {
            set_type(static_cast< ::Opcode_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_basic;
        break;
      }
      
      // optional .Opcode.Basic basic = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_basic:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Opcode_Basic_IsValid(value)) {
            set_basic(static_cast< ::Opcode_Basic >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_advanced;
        break;
      }
      
      // optional .Opcode.Advanced advanced = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_advanced:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Opcode_Advanced_IsValid(value)) {
            set_advanced(static_cast< ::Opcode_Advanced >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Opcode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Opcode.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }
  
  // optional .Opcode.Basic basic = 2;
  if (has_basic()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->basic(), output);
  }
  
  // optional .Opcode.Advanced advanced = 3;
  if (has_advanced()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->advanced(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Opcode::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .Opcode.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }
  
  // optional .Opcode.Basic basic = 2;
  if (has_basic()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->basic(), target);
  }
  
  // optional .Opcode.Advanced advanced = 3;
  if (has_advanced()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->advanced(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Opcode::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Opcode.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }
    
    // optional .Opcode.Basic basic = 2;
    if (has_basic()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->basic());
    }
    
    // optional .Opcode.Advanced advanced = 3;
    if (has_advanced()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->advanced());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Opcode::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Opcode* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Opcode*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Opcode::MergeFrom(const Opcode& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_basic()) {
      set_basic(from.basic());
    }
    if (from.has_advanced()) {
      set_advanced(from.advanced());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Opcode::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Opcode::CopyFrom(const Opcode& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Opcode::IsInitialized() const {
  
  return true;
}

void Opcode::Swap(Opcode* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(basic_, other->basic_);
    std::swap(advanced_, other->advanced_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Opcode::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Opcode_descriptor_;
  metadata.reflection = Opcode_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Operand_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Operand_Type_descriptor_;
}
bool Operand_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 8:
    case 16:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Operand_Type Operand::REGISTER;
const Operand_Type Operand::LOCATION_IN_REGISTER;
const Operand_Type Operand::LOCATION_OFFSET_BY_REGISTER;
const Operand_Type Operand::PUSH_POP;
const Operand_Type Operand::PEEK;
const Operand_Type Operand::PICK;
const Operand_Type Operand::STACK_POINTER;
const Operand_Type Operand::PROGRAM_COUNTER;
const Operand_Type Operand::EXTRA;
const Operand_Type Operand::LOCATION;
const Operand_Type Operand::LITERAL;
const Operand_Type Operand::Type_MIN;
const Operand_Type Operand::Type_MAX;
const int Operand::Type_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* Operand_Register_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Operand_Register_descriptor_;
}
bool Operand_Register_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Operand_Register Operand::A;
const Operand_Register Operand::B;
const Operand_Register Operand::C;
const Operand_Register Operand::X;
const Operand_Register Operand::Y;
const Operand_Register Operand::Z;
const Operand_Register Operand::I;
const Operand_Register Operand::J;
const Operand_Register Operand::Register_MIN;
const Operand_Register Operand::Register_MAX;
const int Operand::Register_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Operand::kTypeFieldNumber;
const int Operand::kRegisterFieldNumber;
const int Operand::kValueFieldNumber;
const int Operand::kLabelFieldNumber;
#endif  // !_MSC_VER

Operand::Operand()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Operand::InitAsDefaultInstance() {
}

Operand::Operand(const Operand& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Operand::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  register__ = 0;
  value_ = 0;
  label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Operand::~Operand() {
  SharedDtor();
}

void Operand::SharedDtor() {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    delete label_;
  }
  if (this != default_instance_) {
  }
}

void Operand::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Operand::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Operand_descriptor_;
}

const Operand& Operand::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_program_2eproto();  return *default_instance_;
}

Operand* Operand::default_instance_ = NULL;

Operand* Operand::New() const {
  return new Operand;
}

void Operand::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    register__ = 0;
    value_ = 0;
    if (has_label()) {
      if (label_ != &::google::protobuf::internal::kEmptyString) {
        label_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Operand::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Operand.Type type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Operand_Type_IsValid(value)) {
            set_type(static_cast< ::Operand_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_register;
        break;
      }
      
      // optional .Operand.Register register = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_register:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Operand_Register_IsValid(value)) {
            set_register_(static_cast< ::Operand_Register >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_value;
        break;
      }
      
      // optional sint32 value = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_label;
        break;
      }
      
      // optional string label = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_label:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_label()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->label().data(), this->label().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Operand::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Operand.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }
  
  // optional .Operand.Register register = 2;
  if (has_register_()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->register_(), output);
  }
  
  // optional sint32 value = 3;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(3, this->value(), output);
  }
  
  // optional string label = 4;
  if (has_label()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->label().data(), this->label().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->label(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Operand::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .Operand.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }
  
  // optional .Operand.Register register = 2;
  if (has_register_()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->register_(), target);
  }
  
  // optional sint32 value = 3;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(3, this->value(), target);
  }
  
  // optional string label = 4;
  if (has_label()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->label().data(), this->label().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->label(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Operand::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Operand.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }
    
    // optional .Operand.Register register = 2;
    if (has_register_()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->register_());
    }
    
    // optional sint32 value = 3;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->value());
    }
    
    // optional string label = 4;
    if (has_label()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->label());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Operand::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Operand* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Operand*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Operand::MergeFrom(const Operand& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_register_()) {
      set_register_(from.register_());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
    if (from.has_label()) {
      set_label(from.label());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Operand::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Operand::CopyFrom(const Operand& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Operand::IsInitialized() const {
  
  return true;
}

void Operand::Swap(Operand* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(register__, other->register__);
    std::swap(value_, other->value_);
    std::swap(label_, other->label_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Operand::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Operand_descriptor_;
  metadata.reflection = Operand_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Data_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Data_Type_descriptor_;
}
bool Data_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Data_Type Data::STRING;
const Data_Type Data::BYTES;
const Data_Type Data::Type_MIN;
const Data_Type Data::Type_MAX;
const int Data::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Data::kTypeFieldNumber;
const int Data::kStringFieldNumber;
const int Data::kBytesFieldNumber;
#endif  // !_MSC_VER

Data::Data()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Data::InitAsDefaultInstance() {
}

Data::Data(const Data& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Data::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  bytes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Data::~Data() {
  SharedDtor();
}

void Data::SharedDtor() {
  if (string_ != &::google::protobuf::internal::kEmptyString) {
    delete string_;
  }
  if (bytes_ != &::google::protobuf::internal::kEmptyString) {
    delete bytes_;
  }
  if (this != default_instance_) {
  }
}

void Data::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Data::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Data_descriptor_;
}

const Data& Data::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_program_2eproto();  return *default_instance_;
}

Data* Data::default_instance_ = NULL;

Data* Data::New() const {
  return new Data;
}

void Data::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    if (has_string()) {
      if (string_ != &::google::protobuf::internal::kEmptyString) {
        string_->clear();
      }
    }
    if (has_bytes()) {
      if (bytes_ != &::google::protobuf::internal::kEmptyString) {
        bytes_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Data::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Data.Type type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Data_Type_IsValid(value)) {
            set_type(static_cast< ::Data_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_string;
        break;
      }
      
      // optional string string = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_string:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_string()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->string().data(), this->string().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_bytes;
        break;
      }
      
      // optional bytes bytes = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_bytes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_bytes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Data::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Data.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }
  
  // optional string string = 2;
  if (has_string()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->string().data(), this->string().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->string(), output);
  }
  
  // optional bytes bytes = 3;
  if (has_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->bytes(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Data::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .Data.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }
  
  // optional string string = 2;
  if (has_string()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->string().data(), this->string().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->string(), target);
  }
  
  // optional bytes bytes = 3;
  if (has_bytes()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->bytes(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Data::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Data.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }
    
    // optional string string = 2;
    if (has_string()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->string());
    }
    
    // optional bytes bytes = 3;
    if (has_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->bytes());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Data::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Data* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Data*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Data::MergeFrom(const Data& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_string()) {
      set_string(from.string());
    }
    if (from.has_bytes()) {
      set_bytes(from.bytes());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Data::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Data::CopyFrom(const Data& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Data::IsInitialized() const {
  
  return true;
}

void Data::Swap(Data* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(string_, other->string_);
    std::swap(bytes_, other->bytes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Data::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Data_descriptor_;
  metadata.reflection = Data_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
